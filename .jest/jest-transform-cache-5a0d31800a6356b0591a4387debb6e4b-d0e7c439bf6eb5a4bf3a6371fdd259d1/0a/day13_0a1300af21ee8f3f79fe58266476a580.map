{"version":3,"sources":["day13.js"],"names":["isOpen","x","y","magicNumber","num","toString","split","filter","length","getNeighbors","point","distance","p","cellId","solveMaze","input","source","destination","parseInt","queue","maze","open","next","shift","neighbors","forEach","concat","part1","part2","Object","values"],"mappings":"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","sourcesContent":["function isOpen({ x, y }, magicNumber) {\n  const num = x * x + 3 * x + 2 * x * y + y + y * y + magicNumber;\n  return (\n    num\n      .toString(2)\n      .split('')\n      .filter(x => x === '1').length %\n      2 ===\n    0\n  );\n}\n\nfunction getNeighbors(point) {\n  return [\n    { x: point.x - 1, y: point.y, distance: point.distance + 1 },\n    { x: point.x + 1, y: point.y, distance: point.distance + 1 },\n    { x: point.x, y: point.y - 1, distance: point.distance + 1 },\n    { x: point.x, y: point.y + 1, distance: point.distance + 1 },\n  ].filter(p => p.x >= 0 && p.y >= 0);\n}\n\nfunction cellId({ x, y }) {\n  return `${x}-${y}`;\n}\n\nfunction solveMaze(input, source, destination) {\n  const magicNumber = parseInt(input);\n  let queue = [source];\n  const maze = { [cellId(source)]: { distance: 0, open: true } };\n  while (queue.length) {\n    const next = queue.shift();\n    if (next.x === destination.x && next.y === destination.y) {\n      return maze;\n    } else {\n      const neighbors = getNeighbors(next).filter(x => !maze[cellId(x)]);\n      const distance = maze[cellId(next)].distance + 1;\n      neighbors.forEach(\n        x => (maze[cellId(x)] = { distance, open: isOpen(x, magicNumber) }),\n      );\n      queue = queue.concat(neighbors.filter(x => maze[cellId(x)].open));\n    }\n  }\n}\n\nexport function part1(input, destination = { x: 31, y: 39 }) {\n  const maze = solveMaze(input, { x: 1, y: 1 }, destination);\n  return maze[cellId(destination)].distance;\n}\n\nexport function part2(input, destination = { x: 31, y: 39 }) {\n  const maze = solveMaze(input, { x: 1, y: 1 }, destination);\n  return Object.values(maze).filter(x => x.distance <= 50 && x.open).length;\n}\n"]}