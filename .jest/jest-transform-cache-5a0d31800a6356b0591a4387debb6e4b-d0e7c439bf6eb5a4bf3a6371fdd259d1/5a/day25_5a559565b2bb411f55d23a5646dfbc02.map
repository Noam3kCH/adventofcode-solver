{"version":3,"sources":["day25.js"],"names":["parse","input","initial","diagnostic","currentState","currentValue","lines","split","states","line","word","match","param","parseInt","write","move","next","part1","tape","position","i","Object","values","filter","x","length","part2","undefined"],"mappings":"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","sourcesContent":["function parse(input) {\n  let initial, diagnostic, currentState, currentValue;\n  const lines = input.split('\\n');\n  const states = {};\n  for (const line of lines) {\n    const word = (line.match(/\\w+/) || [])[0];\n    const param = (line.match(/([^\\s]*).$/) || [])[1];\n    if (word === 'Begin') {\n      initial = param;\n    } else if (word === 'Perform') {\n      diagnostic = parseInt(line.match(/(\\d+) steps.$/)[1], 10);\n    } else if (word === 'In') {\n      currentState = param;\n      states[currentState] = [];\n    } else if (word === 'If') {\n      currentValue = param;\n      states[currentState][currentValue] = {};\n    } else if (word === 'Write') {\n      states[currentState][currentValue].write = param;\n    } else if (word === 'Move') {\n      states[currentState][currentValue].move = param;\n    } else if (word === 'Continue') {\n      states[currentState][currentValue].next = param;\n    }\n  }\n  return { initial, diagnostic, states };\n}\n\nexport function part1(input) {\n  const { initial, diagnostic, states } = parse(input);\n  const tape = {};\n  let position = 0,\n    currentState = initial;\n  for (let i = 0; i < diagnostic; i++) {\n    const currentValue = tape[position] || '0';\n    tape[position] = states[currentState][currentValue].write;\n    position += states[currentState][currentValue].move === 'left' ? -1 : 1;\n    currentState = states[currentState][currentValue].next;\n  }\n  return Object.values(tape).filter(x => x === '1').length;\n}\n\nexport const part2 = () => undefined;\n"]}