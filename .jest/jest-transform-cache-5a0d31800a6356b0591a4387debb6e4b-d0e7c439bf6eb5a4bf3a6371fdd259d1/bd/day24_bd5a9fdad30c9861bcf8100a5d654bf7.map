{"version":3,"sources":["day24.js"],"names":["parse","input","targets","maze","split","map","line","y","c","x","wall","point","target","parseInt","push","getNeighbors","props","filter","path","source","destination","visited","Set","add","queue","distance","length","shift","neighbors","has","forEach","concat","solve","andBack","back","paths","Combinatorics","combination","toArray","points","options","option","reduce","state","current","prev","size","shortest","Math","min","Infinity","part1","part2"],"mappings":";;;;;;;AAAA;;;;AAEA,SAASA,KAAT,CAAeC,KAAf,EAAsB;AACpB,QAAMC,OAAO,GAAG,EAAhB;AACA,QAAMC,IAAI,GAAGF,KAAK,CAACG,KAAN,CAAY,IAAZ,EAAkBC,GAAlB,CAAsB,CAACC,IAAD,EAAOC,CAAP,KACjCD,IAAI,CAACF,KAAL,CAAW,EAAX,EAAeC,GAAf,CAAmB,CAACG,CAAD,EAAIC,CAAJ,KAAU;AAC3B,QAAID,CAAC,KAAK,GAAV,EAAe;AACb,aAAO;AAAEC,QAAAA,CAAF;AAAKF,QAAAA,CAAL;AAAQG,QAAAA,IAAI,EAAE;AAAd,OAAP;AACD,KAFD,MAEO,IAAIF,CAAC,KAAK,GAAV,EAAe;AACpB,aAAO;AAAEC,QAAAA,CAAF;AAAKF,QAAAA,CAAL;AAAQG,QAAAA,IAAI,EAAE;AAAd,OAAP;AACD,KAFM,MAEA;AACL,YAAMC,KAAK,GAAG;AAAEF,QAAAA,CAAF;AAAKF,QAAAA,CAAL;AAAQG,QAAAA,IAAI,EAAE,KAAd;AAAqBE,QAAAA,MAAM,EAAEC,QAAQ,CAACL,CAAD;AAArC,OAAd;AACAN,MAAAA,OAAO,CAACY,IAAR,CAAaH,KAAb;AACA,aAAOA,KAAP;AACD;AACF,GAVD,CADW,CAAb;AAaA,SAAO;AAAER,IAAAA,IAAF;AAAQD,IAAAA;AAAR,GAAP;AACD;;AAED,SAASa,YAAT,CAAsBZ,IAAtB,EAA4BQ,KAA5B,EAAmCK,KAAnC,EAA0C;AACxC,QAAM;AAAEP,IAAAA,CAAF;AAAKF,IAAAA;AAAL,MAAWI,KAAjB;AACA,SAAO,CACL,EAAE,GAAGK,KAAL;AAAYL,IAAAA,KAAK,EAAER,IAAI,CAACI,CAAD,CAAJ,CAAQE,CAAC,GAAG,CAAZ;AAAnB,GADK,EAEL,EAAE,GAAGO,KAAL;AAAYL,IAAAA,KAAK,EAAER,IAAI,CAACI,CAAD,CAAJ,CAAQE,CAAC,GAAG,CAAZ;AAAnB,GAFK,EAGL,EAAE,GAAGO,KAAL;AAAYL,IAAAA,KAAK,EAAER,IAAI,CAACI,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAZ;AAAnB,GAHK,EAIL,EAAE,GAAGO,KAAL;AAAYL,IAAAA,KAAK,EAAER,IAAI,CAACI,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAZ;AAAnB,GAJK,EAKLQ,MALK,CAKER,CAAC,IAAI,CAACA,CAAC,CAACE,KAAF,CAAQD,IALhB,CAAP;AAMD;;AAED,SAASQ,IAAT,CAAcf,IAAd,EAAoBgB,MAApB,EAA4BC,WAA5B,EAAyC;AACvC,QAAMC,OAAO,GAAG,IAAIC,GAAJ,GAAUC,GAAV,CAAcJ,MAAd,CAAhB;AACA,MAAIK,KAAK,GAAG,CAAC;AAAEC,IAAAA,QAAQ,EAAE,CAAZ;AAAed,IAAAA,KAAK,EAAEQ;AAAtB,GAAD,CAAZ;;AACA,SAAOK,KAAK,CAACE,MAAb,EAAqB;AACnB,UAAM;AAAED,MAAAA,QAAF;AAAYd,MAAAA;AAAZ,QAAsBa,KAAK,CAACG,KAAN,EAA5B;AACA,UAAMC,SAAS,GAAGb,YAAY,CAACZ,IAAD,EAAOQ,KAAP,EAAc;AAC1Cc,MAAAA,QAAQ,EAAEA,QAAQ,GAAG;AADqB,KAAd,CAAZ,CAEfR,MAFe,CAER,CAAC;AAAEN,MAAAA;AAAF,KAAD,KAAe,CAACU,OAAO,CAACQ,GAAR,CAAYlB,KAAZ,CAFR,CAAlB;AAGAiB,IAAAA,SAAS,CAACE,OAAV,CAAkB,CAAC;AAAEnB,MAAAA;AAAF,KAAD,KAAeU,OAAO,CAACE,GAAR,CAAYZ,KAAZ,CAAjC;;AACA,QAAIU,OAAO,CAACQ,GAAR,CAAYT,WAAZ,CAAJ,EAA8B;AAC5B,aAAOK,QAAQ,GAAG,CAAlB;AACD;;AACDD,IAAAA,KAAK,GAAGA,KAAK,CAACO,MAAN,CAAaH,SAAb,CAAR;AACD;AACF;;AAED,SAASI,KAAT,CAAe;AAAE7B,EAAAA,IAAF;AAAQD,EAAAA;AAAR,CAAf,EAAkC+B,OAAlC,EAA2C;AACzC,QAAMC,IAAI,GAAG,EAAb;;AACA,QAAMC,KAAK,GAAGC,yBAAcC,WAAd,CAA0BnC,OAA1B,EAAmC,CAAnC,EACXoC,OADW,GAEXjC,GAFW,CAEP,CAAC,CAACc,MAAD,EAASC,WAAT,CAAD,KAA2B;AAC9B,UAAMK,QAAQ,GAAGP,IAAI,CAACf,IAAD,EAAOgB,MAAP,EAAeC,WAAf,CAArB;;AACA,QAAID,MAAM,CAACP,MAAP,KAAkB,CAAlB,IAAuBQ,WAAW,CAACR,MAAZ,KAAuB,CAAlD,EAAqD;AACnDsB,MAAAA,IAAI,CAACf,MAAM,CAACP,MAAP,GAAgBQ,WAAW,CAACR,MAA7B,CAAJ,GAA2Ca,QAA3C;AACD;;AACD,WAAO;AAAEc,MAAAA,MAAM,EAAE,CAACpB,MAAM,CAACP,MAAR,EAAgBQ,WAAW,CAACR,MAA5B,CAAV;AAA+Ca,MAAAA;AAA/C,KAAP;AACD,GARW,CAAd;;AAUA,QAAMe,OAAO,GAAGJ,yBAAcC,WAAd,CAA0BF,KAA1B,EAAiCjC,OAAO,CAACwB,MAAR,GAAiB,CAAlD,EACbrB,GADa,CACToC,MAAM,IAAI;AACb,UAAMF,MAAM,GAAGE,MAAM,CAACC,MAAP,CAAc,CAACH,MAAD,EAASrB,IAAT,KAAkB;AAC7CqB,MAAAA,MAAM,CAACrB,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAAD,CAAN,GAAyB,CAACA,MAAM,CAACrB,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAAD,CAAN,IAA0B,EAA3B,EAA+BR,MAA/B,CAAsC,CAC7Db,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAD6D,CAAtC,CAAzB;AAGAA,MAAAA,MAAM,CAACrB,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAAD,CAAN,GAAyB,CAACA,MAAM,CAACrB,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAAD,CAAN,IAA0B,EAA3B,EAA+BR,MAA/B,CAAsC,CAC7Db,IAAI,CAACqB,MAAL,CAAY,CAAZ,CAD6D,CAAtC,CAAzB;AAGA,aAAOA,MAAP;AACD,KARc,EAQZ,EARY,CAAf;AASA,UAAMI,KAAK,GAAG;AAAEC,MAAAA,OAAO,EAAE,CAAX;AAAcvB,MAAAA,OAAO,EAAE,IAAIC,GAAJ,GAAUC,GAAV,CAAc,CAAd;AAAvB,KAAd;;AACA,WAAOgB,MAAM,CAACI,KAAK,CAACC,OAAP,CAAN,IAAyBL,MAAM,CAACI,KAAK,CAACC,OAAP,CAAN,CAAsBlB,MAAtB,KAAiC,CAAjE,EAAoE;AAClE,YAAMmB,IAAI,GAAGF,KAAK,CAACC,OAAnB;AACAD,MAAAA,KAAK,CAACC,OAAN,GAAgBL,MAAM,CAACI,KAAK,CAACC,OAAP,CAAN,CAAsBjB,KAAtB,EAAhB;AACAY,MAAAA,MAAM,CAACI,KAAK,CAACC,OAAP,CAAN,GAAwBL,MAAM,CAACI,KAAK,CAACC,OAAP,CAAN,CAAsB3B,MAAtB,CAA6BR,CAAC,IAAIA,CAAC,KAAKoC,IAAxC,CAAxB;AACAF,MAAAA,KAAK,CAACtB,OAAN,CAAcE,GAAd,CAAkBoB,KAAK,CAACC,OAAxB;AACD;;AACD,WACED,KAAK,CAACtB,OAAN,CAAcyB,IAAd,KAAuB5C,OAAO,CAACwB,MAA/B,IAAyC;AACvCA,MAAAA,MAAM,EAAEe,MAAM,CAACC,MAAP,CACN,CAACjB,QAAD,EAAWP,IAAX,KAAoBO,QAAQ,GAAGP,IAAI,CAACO,QAD9B,EAEN,CAFM,CAD+B;AAKvCS,MAAAA,IAAI,EAAEA,IAAI,CAACS,KAAK,CAACC,OAAP;AAL6B,KAD3C;AASD,GA3Ba,EA4Bb3B,MA5Ba,CA4BNR,CAAC,IAAIA,CA5BC,CAAhB;;AA8BA,SAAO+B,OAAO,CAACE,MAAR,CAAe,CAACK,QAAD,EAAWN,MAAX,KAAsB;AAC1C,WAAOO,IAAI,CAACC,GAAL,CACLF,QADK,EAELd,OAAO,GAAGQ,MAAM,CAACf,MAAP,GAAgBe,MAAM,CAACP,IAA1B,GAAiCO,MAAM,CAACf,MAF1C,CAAP;AAID,GALM,EAKJwB,QALI,CAAP;AAMD;;AAEM,MAAMC,KAAK,GAAGlD,KAAK,IAAI+B,KAAK,CAAChC,KAAK,CAACC,KAAD,CAAN,EAAe,KAAf,CAA5B;;;;AACA,MAAMmD,KAAK,GAAGnD,KAAK,IAAI+B,KAAK,CAAChC,KAAK,CAACC,KAAD,CAAN,EAAe,IAAf,CAA5B","sourcesContent":["import Combinatorics from 'js-combinatorics';\n\nfunction parse(input) {\n  const targets = [];\n  const maze = input.split('\\n').map((line, y) =>\n    line.split('').map((c, x) => {\n      if (c === '#') {\n        return { x, y, wall: true };\n      } else if (c === '.') {\n        return { x, y, wall: false };\n      } else {\n        const point = { x, y, wall: false, target: parseInt(c) };\n        targets.push(point);\n        return point;\n      }\n    }),\n  );\n  return { maze, targets };\n}\n\nfunction getNeighbors(maze, point, props) {\n  const { x, y } = point;\n  return [\n    { ...props, point: maze[y][x - 1] },\n    { ...props, point: maze[y][x + 1] },\n    { ...props, point: maze[y - 1][x] },\n    { ...props, point: maze[y + 1][x] },\n  ].filter(x => !x.point.wall);\n}\n\nfunction path(maze, source, destination) {\n  const visited = new Set().add(source);\n  let queue = [{ distance: 0, point: source }];\n  while (queue.length) {\n    const { distance, point } = queue.shift();\n    const neighbors = getNeighbors(maze, point, {\n      distance: distance + 1,\n    }).filter(({ point }) => !visited.has(point));\n    neighbors.forEach(({ point }) => visited.add(point));\n    if (visited.has(destination)) {\n      return distance + 1;\n    }\n    queue = queue.concat(neighbors);\n  }\n}\n\nfunction solve({ maze, targets }, andBack) {\n  const back = {};\n  const paths = Combinatorics.combination(targets, 2)\n    .toArray()\n    .map(([source, destination]) => {\n      const distance = path(maze, source, destination);\n      if (source.target === 0 || destination.target === 0) {\n        back[source.target + destination.target] = distance;\n      }\n      return { points: [source.target, destination.target], distance };\n    });\n\n  const options = Combinatorics.combination(paths, targets.length - 1)\n    .map(option => {\n      const points = option.reduce((points, path) => {\n        points[path.points[0]] = (points[path.points[0]] || []).concat([\n          path.points[1],\n        ]);\n        points[path.points[1]] = (points[path.points[1]] || []).concat([\n          path.points[0],\n        ]);\n        return points;\n      }, {});\n      const state = { current: 0, visited: new Set().add(0) };\n      while (points[state.current] && points[state.current].length === 1) {\n        const prev = state.current;\n        state.current = points[state.current].shift();\n        points[state.current] = points[state.current].filter(x => x !== prev);\n        state.visited.add(state.current);\n      }\n      return (\n        state.visited.size === targets.length && {\n          length: option.reduce(\n            (distance, path) => distance + path.distance,\n            0,\n          ),\n          back: back[state.current],\n        }\n      );\n    })\n    .filter(x => x);\n\n  return options.reduce((shortest, option) => {\n    return Math.min(\n      shortest,\n      andBack ? option.length + option.back : option.length,\n    );\n  }, Infinity);\n}\n\nexport const part1 = input => solve(parse(input), false);\nexport const part2 = input => solve(parse(input), true);\n"]}