{"version":3,"sources":["day19.js"],"names":["calcNeighbors","molecule","replacements","reduce","result","pair","regexp","RegExp","from","exec","push","slice","lastIndex","length","to","sort","filter","x","index","arr","calcDistance","src","dest","queue","cost","heuristic","p","map","shift","forEach","next","newCost","a","b","parse","input","split","pop","match","part1","part2"],"mappings":"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","sourcesContent":["function calcNeighbors({ molecule, replacements }) {\n  return replacements\n    .reduce((result, pair) => {\n      const regexp = new RegExp(pair.from, 'g');\n      while (regexp.exec(molecule)) {\n        result.push(\n          molecule.slice(0, regexp.lastIndex - pair.from.length) +\n            pair.to +\n            molecule.slice(regexp.lastIndex),\n        );\n      }\n      return result;\n    }, [])\n    .sort()\n    .filter((x, index, arr) => x !== arr[index - 1]);\n}\n\nfunction calcDistance(src, { molecule: dest, replacements }) {\n  let queue = [dest];\n  const cost = { [dest]: 0 };\n  const heuristic = p => cost[p] + p.length - src.length;\n  replacements = replacements.map(x => ({ from: x.to, to: x.from }));\n\n  while (queue.length) {\n    const molecule = queue.shift();\n    if (molecule === src) {\n      return cost[src];\n    }\n    /* eslint no-loop-func: \"off\" */\n    calcNeighbors({ molecule, replacements }).forEach(next => {\n      const newCost = cost[molecule] + 1;\n      if (!cost[next] || newCost < cost[next]) {\n        cost[next] = newCost;\n        queue.push(next);\n      }\n    });\n    queue = queue.sort().filter((x, index, arr) => x !== arr[index - 1]);\n    queue = queue.sort((a, b) => heuristic(a) - heuristic(b)); //A* priority queue\n  }\n}\n\nfunction parse(input) {\n  input = input.split('\\n');\n  const molecule = input.pop();\n  input.pop();\n  const replacements = input\n    .map(x => x.match(/^(\\w+) => (\\w+)$/))\n    .map(x => ({ from: x[1], to: x[2] }));\n  return { molecule, replacements };\n}\n\nexport const part1 = input => calcNeighbors(parse(input)).length;\nexport const part2 = input => calcDistance('e', parse(input));\n"]}