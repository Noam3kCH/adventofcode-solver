{"version":3,"sources":["day23.js"],"names":["parseDebug","input","debug","sub","p1","p2","state","jnz","instruction","part1","commands","x","length","mul","isPrime","num","sqrt","Math","floor","i","part2","parseInt","split","shift","pop","count"],"mappings":";;;;;;;;AAAA;;AAEA,SAASA,UAAT,CAAoBC,KAApB,EAA2BC,KAA3B,EAAkC;AAChC,SAAO,gBACLD,KADK,EAEL;AACEE,IAAAA,GAAG,EAAE,CAACC,EAAD,EAAKC,EAAL,KAAYC,KAAK,IACnBA,KAAK,CAACF,EAAD,CAAL,GAAY,iBAAOE,KAAP,EAAcF,EAAd,IAAoB,iBAAOE,KAAP,EAAcD,EAAd,CAFrC;AAGEE,IAAAA,GAAG,EAAE,CAACH,EAAD,EAAKC,EAAL,KAAYC,KAAK,IACpB,iBAAOA,KAAP,EAAcF,EAAd,MAAsB,CAAtB,GACKE,KAAK,CAACE,WAAN,IAAqB,iBAAOF,KAAP,EAAcD,EAAd,IAAoB,CAD9C,GAEI;AANR,GAFK,EAULH,KAVK,CAAP;AAYD;;AAEM,SAASO,KAAT,CAAeR,KAAf,EAAsB;AAC3B,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMQ,QAAQ,GAAGV,UAAU,CAACC,KAAD,EAAQU,CAAC,IAAKT,KAAK,CAACS,CAAD,CAAL,GAAW,CAACT,KAAK,CAACS,CAAD,CAAL,IAAY,CAAb,IAAkB,CAA3C,CAA3B;AACA,QAAML,KAAK,GAAG;AAAEE,IAAAA,WAAW,EAAE;AAAf,GAAd;;AACA,SAAOF,KAAK,CAACE,WAAN,GAAoBE,QAAQ,CAACE,MAApC,EAA4C;AAC1CF,IAAAA,QAAQ,CAACJ,KAAK,CAACE,WAAP,CAAR,CAA4BF,KAA5B;AACAA,IAAAA,KAAK,CAACE,WAAN;AACD;;AACD,SAAON,KAAK,CAACW,GAAb;AACD;;AAED,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,QAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACD,IAAL,CAAUD,GAAV,CAAX,CAAb;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,GAAG,CAA3B,EAA8BG,CAAC,EAA/B,EAAmC;AACjC,QAAIJ,GAAG,GAAGI,CAAN,KAAY,CAAhB,EAAmB;AACjB,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAEM,SAASC,KAAT,CAAenB,KAAf,EAAsB;AAC3B,QAAMc,GAAG,GACPM,QAAQ,CACNpB,KAAK,CACFqB,KADH,CACS,IADT,EAEGC,KAFH,GAGGD,KAHH,CAGS,GAHT,EAIGE,GAJH,EADM,EAMN,EANM,CAAR,GAQE,GARF,GASA,GAVF;AAWA,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAArB,EAA4BA,CAAC,IAAI,EAAjC,EAAqC;AACnC,QAAI,CAACL,OAAO,CAACC,GAAG,GAAGI,CAAP,CAAZ,EAAuB;AACrBM,MAAAA,KAAK;AACN;AACF;;AACD,SAAOA,KAAP;AACD","sourcesContent":["import { parse, getter } from './day18.js';\n\nfunction parseDebug(input, debug) {\n  return parse(\n    input,\n    {\n      sub: (p1, p2) => state =>\n        (state[p1] = getter(state, p1) - getter(state, p2)),\n      jnz: (p1, p2) => state =>\n        getter(state, p1) !== 0\n          ? (state.instruction += getter(state, p2) - 1)\n          : null,\n    },\n    debug,\n  );\n}\n\nexport function part1(input) {\n  const debug = {};\n  const commands = parseDebug(input, x => (debug[x] = (debug[x] || 0) + 1));\n  const state = { instruction: 0 };\n  while (state.instruction < commands.length) {\n    commands[state.instruction](state);\n    state.instruction++;\n  }\n  return debug.mul;\n}\n\nfunction isPrime(num) {\n  const sqrt = Math.floor(Math.sqrt(num));\n  for (let i = 2; i < sqrt + 1; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function part2(input) {\n  const num =\n    parseInt(\n      input\n        .split('\\n')\n        .shift()\n        .split(' ')\n        .pop(),\n      10,\n    ) *\n      100 +\n    1e5;\n  let count = 0;\n  for (let i = 0; i <= 17000; i += 17) {\n    if (!isPrime(num + i)) {\n      count++;\n    }\n  }\n  return count;\n}\n"]}