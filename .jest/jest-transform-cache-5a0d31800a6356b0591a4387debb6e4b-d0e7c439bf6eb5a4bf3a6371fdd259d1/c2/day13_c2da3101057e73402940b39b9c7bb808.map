{"version":3,"sources":["day13.js"],"names":["longest","graph","curr","visited","paths","Object","keys","filter","node","indexOf","map","concat","length","Math","max","apply","parse","input","signs","gain","lose","split","x","match","p1","p2","d","parseInt","reduce","edge","prev","$$me","obj","key","part1","shift","part2"],"mappings":"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","sourcesContent":["function longest(graph, curr, visited) {\n  const paths = Object.keys(graph[curr])\n    .filter(node => visited.indexOf(node) === -1)\n    .map(\n      node => graph[curr][node] + longest(graph, node, visited.concat(curr)),\n    );\n  return paths.length\n    ? Math.max.apply(Math, paths)\n    : graph[curr][visited[0]] || 0;\n}\n\nfunction parse(input) {\n  const signs = { gain: +1, lose: -1 };\n  const graph = input\n    .split('\\n')\n    .map(x =>\n      x.match(/^(.*) would (gain|lose) (\\d+) happiness .* next to (.*)\\.$/),\n    )\n    .map(x => ({ p1: x[1], p2: x[4], d: signs[x[2]] * parseInt(x[3]) }))\n    .reduce((graph, edge) => {\n      const prev = (graph[edge.p1] && graph[edge.p1][edge.p2]) || 0;\n      graph[edge.p1] = { ...graph[edge.p1], [edge.p2]: edge.d + prev };\n      graph[edge.p2] = { ...graph[edge.p2], [edge.p1]: edge.d + prev };\n      return graph;\n    }, {});\n  graph.$$me = Object.keys(graph).reduce(\n    (obj, key) => ({ [key]: 0, ...obj }),\n    {},\n  );\n  return graph;\n}\n\nexport function part1(input) {\n  const graph = parse(input);\n  return longest(graph, Object.keys(graph).shift(), []);\n}\n\nexport function part2(input) {\n  const graph = parse(input);\n  return longest(graph, '$$me', []);\n}\n"]}