{"version":3,"sources":["day14.js"],"names":["findRepeatingCharacters","str","num","match","RegExp","map","x","generateKeys","input","hashFn","keys","window","characters","i","length","forEach","concat","digit","shift","index","undefined","find","push","md5times","count","part1","pop","part2"],"mappings":";;;;;;;AAAA;;;;AAEA,SAASA,uBAAT,CAAiCC,GAAjC,EAAsCC,GAAtC,EAA2C;AACzC,SAAO,CAACD,GAAG,CAACE,KAAJ,CAAU,IAAIC,MAAJ,CAAY,UAASF,GAAG,GAAG,CAAE,GAA7B,EAAiC,GAAjC,CAAV,KAAoD,EAArD,EAAyDG,GAAzD,CACLC,CAAC,IAAIA,CAAC,CAAC,CAAD,CADD,CAAP;AAGD;;AAED,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,MAA7B,EAAqC;AACnC,QAAMC,IAAI,GAAG,EAAb;AAAA,QACEC,MAAM,GAAG,EADX;AAAA,QAEEC,UAAU,GAAG,EAFf;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBH,IAAI,CAACI,MAAL,GAAc,EAA9B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAMZ,GAAG,GAAGQ,MAAM,CAAE,GAAED,KAAM,GAAEK,CAAE,EAAd,CAAlB;AACAb,IAAAA,uBAAuB,CAACC,GAAD,EAAM,CAAN,CAAvB,CAAgCc,OAAhC,CACET,CAAC,IAAKM,UAAU,CAACN,CAAD,CAAV,GAAgB,CAACM,UAAU,CAACN,CAAD,CAAV,IAAiB,EAAlB,EAAsBU,MAAtB,CAA6B,CAACH,CAAD,CAA7B,CADxB;;AAGA,QAAIA,CAAC,IAAI,IAAT,EAAe;AACb,YAAMI,KAAK,GAAGjB,uBAAuB,CAACW,MAAM,CAACO,KAAP,EAAD,EAAiB,CAAjB,CAAvB,CAA2CA,KAA3C,EAAd;AACA,YAAMC,KAAK,GACTF,KAAK,KAAKG,SAAV,IACAR,UAAU,CAACK,KAAD,CADV,IAEAL,UAAU,CAACK,KAAD,CAAV,CAAkBI,IAAlB,CAAuBf,CAAC,IAAIA,CAAC,GAAGO,CAAC,GAAG,IAApC,CAHF;;AAIA,UAAIM,KAAJ,EAAW;AACTT,QAAAA,IAAI,CAACY,IAAL,CAAUT,CAAC,GAAG,IAAd;AACD;AACF;;AACDF,IAAAA,MAAM,CAACW,IAAP,CAAYrB,GAAZ;AACD;;AACD,SAAOS,IAAP;AACD;;AAED,SAASa,QAAT,CAAkBtB,GAAlB,EAAuBuB,KAAvB,EAA8B;AAC5B,SAAOA,KAAK,GAAG,CAAf,EAAkB;AAChBvB,IAAAA,GAAG,GAAG,iBAAIA,GAAJ,CAAN;AACAuB,IAAAA,KAAK;AACN;;AACD,SAAOvB,GAAP;AACD;;AAEM,MAAMwB,KAAK,GAAGjB,KAAK,IAAID,YAAY,CAACC,KAAD,EAAQF,CAAC,IAAIiB,QAAQ,CAACjB,CAAD,EAAI,CAAJ,CAArB,CAAZ,CAAyCoB,GAAzC,EAAvB;;;;AACA,MAAMC,KAAK,GAAGnB,KAAK,IAAID,YAAY,CAACC,KAAD,EAAQF,CAAC,IAAIiB,QAAQ,CAACjB,CAAD,EAAI,IAAJ,CAArB,CAAZ,CAA4CoB,GAA5C,EAAvB","sourcesContent":["import md5 from '../utils/md5.js';\n\nfunction findRepeatingCharacters(str, num) {\n  return (str.match(new RegExp(`(.)\\\\1{${num - 1}}`, 'g')) || []).map(\n    x => x[0],\n  );\n}\n\nfunction generateKeys(input, hashFn) {\n  const keys = [],\n    window = [],\n    characters = {};\n  for (let i = 0; keys.length < 64; i++) {\n    const str = hashFn(`${input}${i}`);\n    findRepeatingCharacters(str, 5).forEach(\n      x => (characters[x] = (characters[x] || []).concat([i])),\n    );\n    if (i >= 1000) {\n      const digit = findRepeatingCharacters(window.shift(), 3).shift();\n      const index =\n        digit !== undefined &&\n        characters[digit] &&\n        characters[digit].find(x => x > i - 1000);\n      if (index) {\n        keys.push(i - 1000);\n      }\n    }\n    window.push(str);\n  }\n  return keys;\n}\n\nfunction md5times(str, count) {\n  while (count > 0) {\n    str = md5(str);\n    count--;\n  }\n  return str;\n}\n\nexport const part1 = input => generateKeys(input, x => md5times(x, 1)).pop();\nexport const part2 = input => generateKeys(input, x => md5times(x, 2017)).pop();\n"]}