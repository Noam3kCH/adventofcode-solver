{"version":3,"sources":["day07.js"],"names":["abc","next","prerequisites","done","options","step","prerequisite","includes","every","x","push","sort","shift","next2","pending","workers","base","now","length","a","b","time","find","map","indexOf","parse","input","Map","split","match","forEach","required","set","get","concat","part1","steps","Array","from","keys","join","part2","pop"],"mappings":"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","sourcesContent":["const abc = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\nfunction next(prerequisites, done) {\n  const options = [];\n  for (const [step, prerequisite] of prerequisites) {\n    if (!done.includes(step) && prerequisite.every(x => done.includes(x))) {\n      options.push(step);\n    }\n  }\n  done.push(options.sort().shift());\n}\n\nfunction next2(prerequisites, done, pending, workers, base) {\n  let now = 0;\n  if (pending.length) {\n    done.push(pending.sort((a, b) => a.time - b.time).shift());\n    now = done[done.length - 1].time;\n  }\n\n  let options = [];\n  for (const [step, prerequisite] of prerequisites) {\n    if (\n      !done.find(x => x.step === step) &&\n      !pending.find(x => x.step === step) &&\n      prerequisite.every(step => done.find(x => x.step === step))\n    ) {\n      options.push(step);\n    }\n  }\n\n  options = options\n    .sort()\n    .map(x => ({ step: x, time: now + base + abc.indexOf(x) }));\n  while (pending.length < workers && options.length) {\n    pending.push(options.shift());\n  }\n}\n\nfunction parse(input) {\n  const prerequisites = new Map();\n  input\n    .split('\\n')\n    .map(x => x.match(/([A-Z]) must be finished before step ([A-Z])/))\n    .forEach(([, required, step]) => {\n      prerequisites.set(step, (prerequisites.get(step) || []).concat(required));\n      prerequisites.set(required, prerequisites.get(required) || []);\n    });\n  return prerequisites;\n}\n\nexport function part1(input) {\n  const done = [];\n  const prerequisites = parse(input);\n  const steps = Array.from(prerequisites.keys()).length;\n  while (done.length < steps) {\n    next(prerequisites, done);\n  }\n  return done.join('');\n}\n\nexport function part2(input, workers = 5, base = 60) {\n  const done = [];\n  const pending = [];\n  const prerequisites = parse(input);\n  const steps = Array.from(prerequisites.keys()).length;\n  while (done.length < steps) {\n    next2(prerequisites, done, pending, workers, base);\n  }\n  return done.pop().time;\n}\n"]}