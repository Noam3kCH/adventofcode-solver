{"version":3,"sources":["day16.js"],"names":["parse","input","length","regexp","rebuild","arr","join","swap","a","b","RegExp","ops","x","str","match","slice","p","i","j","indexOf","sort","s","reverse","params","parseInt","split","map","cmd","op","args","dance","order","commands","reduce","part1","part2","times","memory","loop"],"mappings":"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","sourcesContent":["function parse(input, length) {\n  const regexp = /^(s|x|p)([^/]*)\\/?([^/]*)$/;\n  const rebuild = arr => [arr[0], arr[3], arr[2], arr[1], arr[4]].join('');\n  const swap = (a, b) => new RegExp(`^(.{${a}})(.)(.{${b - a - 1}})(.)(.*)$`);\n  const ops = {\n    x: (str, regexp) => rebuild(str.match(regexp).slice(1)),\n    p: (str, [a, b]) => {\n      const [i, j] = [str.indexOf(a), str.indexOf(b)].sort((a, b) => a - b);\n      return rebuild(str.match(swap(i, j)).slice(1));\n    },\n    s: (str, regexp) =>\n      str\n        .match(regexp)\n        .slice(1)\n        .reverse()\n        .join(''),\n  };\n  const params = {\n    x: (a, b) => swap(...[parseInt(a), parseInt(b)].sort((a, b) => a - b)),\n    p: (a, b) => [a, b],\n    s: a => new RegExp(`^(.*)(.{${parseInt(a) % length}})$`),\n  };\n  return input\n    .split(',')\n    .map(x => x.match(regexp).slice(1))\n    .map(cmd => {\n      const op = ops[cmd[0]];\n      const args = params[cmd[0]](cmd[1], cmd[2]);\n      return { op, args };\n    });\n}\n\nfunction dance(order, commands) {\n  return commands.reduce((x, { op, args }) => op(x, args), order);\n}\n\nexport function part1(input, order = 'abcdefghijklmnop') {\n  return dance(order, parse(input, order.length));\n}\n\nexport function part2(input, order = 'abcdefghijklmnop', times = 1e9) {\n  const commands = parse(input, order.length);\n  const memory = {};\n  let i;\n  for (i = 0; i < times; i++) {\n    if (memory[order]) {\n      const loop = i - memory[order];\n      i += times - (times % loop);\n      while (i > times - 1) {\n        i -= loop;\n      }\n    } else {\n      memory[order] = i;\n    }\n    order = dance(order, commands);\n  }\n  return order;\n}\n"]}