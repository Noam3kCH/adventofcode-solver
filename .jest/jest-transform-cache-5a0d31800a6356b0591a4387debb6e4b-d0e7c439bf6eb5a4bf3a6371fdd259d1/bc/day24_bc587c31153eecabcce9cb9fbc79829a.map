{"version":3,"sources":["day24.js"],"names":["parse","input","split","map","x","n","parseInt","toKey","item","Array","from","visited","join","sort","strength","port","getNext","components","current","cache","next","filter","has","Set","add","key","solve","compare","max","queue","length","shift","concat","part1","part2","size"],"mappings":"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","sourcesContent":["function parse(input) {\n  return input.split('\\n').map(x => x.split('/').map(n => parseInt(n)));\n}\n\nfunction toKey(item) {\n  return [\n    Array.from(item.visited)\n      .map(x => x.join('-'))\n      .sort()\n      .join(','),\n    item.strength,\n    item.port,\n  ].join(':');\n}\n\nfunction getNext(components, current, cache) {\n  const next = components.filter(x => {\n    return (\n      (x[0] === current.port || x[1] === current.port) &&\n      !current.visited.has(x)\n    );\n  });\n  return next\n    .map(x => {\n      return {\n        visited: new Set(current.visited).add(x),\n        strength: current.strength + x[0] + x[1],\n        port: x[0] === current.port ? x[1] : x[0],\n      };\n    })\n    .filter(x => {\n      const key = toKey(x);\n      return !cache.has(key) && cache.add(key);\n    });\n}\n\nfunction solve(components, compare) {\n  const cache = new Set();\n  let max = { visited: new Set(), strength: 0, port: 0 };\n  let queue = getNext(components, max, cache);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    max = compare(current, max) ? current : max;\n    queue = queue.concat(getNext(components, current, cache));\n  }\n  return max.strength;\n}\n\nexport function part1(input) {\n  const components = parse(input);\n  return solve(components, (current, max) => current.strength > max.strength);\n}\n\nexport function part2(input) {\n  const components = parse(input);\n  return solve(components, (current, max) => {\n    return (\n      current.visited.size > max.visited.size ||\n      (current.visited.size === max.visited.size &&\n        current.strength > max.strength)\n    );\n  });\n}\n"]}